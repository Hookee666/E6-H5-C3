# 面试整理

## 1. Angular、React 和 Vue的比较

### Angular 

Angular是由谷歌开发的一套比较完整的框架 ，api比较全，功能比较完善。最大的特点就是**数据流使用双向绑定**即：**界面的操作能实时反映到数据，数据的变更能实时展现到界面。** 但在项目越来越复杂时，双向数据绑定会带来性能问题。

在Angular的作用域中任何操作的执行都会引发**脏检查机制**，通过跟踪数据的改变再动态更新用户界面（UI）。  随着绑定数量的增加性能就会越低。   

### react

React推崇的是函数式编程和单向数据流：给定原始界面（或数据），施加一个变化，就能推导出另外一个状态（界面或者数据的更新）。 

React更关注UI的组件化，和数据的单向更新，提出了FLUX架构的新概念，现在React可以直接用 ES6语法，然后通过webpack编译成浏览器兼容的ES5，开发效率上有些优势.   

### react与vue

相同之处在于： 
\- **都使用了virtual DOM** 
\- **提供了响应式和组件化的视图组件** 
\- **将注意力集中在核心库，而将其他功能如路由和全局状态管理交给相关的库**

在 **性能方面**，React中，某个组件发生变化，它会以该组件为根，重新渲染整个组件子树。而在Vue组件的依赖是在渲染过程中自动追踪的，能知道哪个组件确实需要被渲染。

在**状态管理方面**，分别使用vuex和Redux来进行全局状态管理。vue的生态系统库没有react繁荣。

在模板方面，vue中html,css,js是分开的，而react中所有组件渲染都依靠JSX,HTML，css,js都是利用jsx.

在**规模方面**的话，vue和react都提供了强大的路由来应对大型应用。

---

## 2. React

React 是一个用于构建用户界面的 JavaScript 库， 起源于 Facebook 的内部项目，主要用于构建UI。React 拥有较高的性能，代码逻辑非常简单。

1. **组件化分工、合作**，通过 React 构建组件，使得代码更加容易得到复用，
2. **灵活** −React可以与其他库或框架很好地配合。
3. **虚拟DOM**—性能高，React通过对DOM的模拟，最大限度地减少与DOM的交互。
4. **跨平台**—ReactNative可以用于移动端

**MVC：MVC模式的意思是，软件可以分成三个部分**

1. View 传送指令到 Controller
2. Controller 完成业务逻辑后，要求 Model 改变状态
3. Model 将新的数据发送到 View，用户得到反馈

#### 虚拟DOM

- 在传统的 Web 应用中，我们往往会把数据的变化实时地更新到用户界面中，于是每次数据的微小变动都会引起 整个DOM 树的重新渲染。频繁的操作很可能会引发性能问题。React 为了解决这个问题，引入了虚拟 DOM 技术。React 通过渲染虚拟 DOM 到浏览器，使得用户界面得以显示。与此同时，React 在虚拟的 DOM 上实现了一个 diff 算法，当要更新组件的时候，会通过 diff 寻找到要变更的 DOM 节点，再把这个修改更新到浏览器实际的 DOM 节点上，所以在 React 中，当页面发生变化时实际上不是真的渲染整个 DOM，React 会通过自身的逻辑和算法，转化为真正的 DOM 节点。也正是因为这样的结构，虚拟 DOM 的性能要比原生 DOM 快很多。

### React生命周期

简单地说，组件的所有状态组合起来就构成了组件的生命周期

`React`定义了组件的生命周期会经历如下三个过程：

- 装载过程（Mount），组件第一次在DOM树渲染的过程。
- 更新过程（Update），当组件的props或者state改变时就会触发组件的更新过程。
- 卸载过程（Unmount），组件从DOM树中删除的过程。

这三个过程就构成了组件的生命周期。

#### 装载过程

该过程会依次调用如下函数：

- `constructor()`:ES6类的构造函数（为了初始化`state`或绑定`this`）
- `getInitialState()`:ES5中初始化`state`。
- `getDefaultProps()`:ES5中初始化`props`。在ES6中使用`defaultProps()`方法。
- `componentWillMount()`:在组件被挂载前调用。只执行一次。
- `render()`:渲染组件，必须实现该方法。
- `componentDidMount()`:在组件装载后调用。这时已经生成了真实的DOM节点。只执行一次。

#### 更新过程

当组件的props或者state改变时就会触发组件的更新过程。

更新过程会依次执行如下函数：

- `componentWillReceiveProps(nextProps)`:当父组件的`render()`方法执行后就会触发该方法。初始化时不调用。
- `shouldComponentUpdate(nextProps,nextState)`:当`props`改变或`state`改变时调用，初始化时不掉用，返回`boolean`。`true`表示继续执行`render`方法，`fasle`表示放弃本次渲染。
- `render()`:渲染组件。

#### 卸载过程

`componentWillUnmount()`:将组件从DOM树移出，防止内存溢出。

---

## 3. TypeScript

 **TypeScript** 是 JavaScript 的一个超集，包含了 JavaScript 的所有元素，可以载入 JavaScript 代码运行，并扩展了 JavaScript 的语法。主要提供了**类型系统**和**对 ES6 的支持****

### **为什么选择 TypeScript？**

- TypeScript 增加了代码的可读性和可维护性

- 类型系统实际上是最好的文档，大部分的函数看看类型的定义就可以知道如何使用了
- 可以在编译阶段就发现大部分错误，这比在运行时候出错好

### JS和 TS 的主要差异 

```
现在的Javascript遵循ECMA5的规范，TypeScript是语法上对ECMA6的实现。但现在的TypeScript需要编译（不是真正的编译，其实就是语法处理）后转换成Javascript才能执行。
TypeScript不是 语法上的ECMA6实现，而是以JavaScript为目标语言的，一种编译语言，并且提供向原生JavaScript转换的编译器；
```

**JavaScript**是一种轻量级的解释性脚本语言，可嵌入到 HTML 页面中，能够实现浏览器端丰富的交互功能，

JavaScript 是基于对象和事件驱动的，无需特定的语言环境，只需在支持的浏览器上就能运行。

JavaScript 的语法简单，使用的变量为弱类型。 

**TypeScript** 使用类型和接口等概念来描述数据，使开发人员能够快速检测错误并调试应用程序 

---

## 4. NodeJS、npm/yarn及webpack

### nodejs：

它是一个Javascript运行环境，依赖于Chrome V8引擎进行代码解释

**最大的优势是借助JavaScript天生的事件驱动机制加V8高性能引擎，使编写高性能Web服务轻而易举。**

其次，JavaScript语言本身是完善的**函数式语言**，在前端开发时，开发人员往往写得比较随意，让人感觉JavaScript就是个“玩具语言”。但是，在Node环境下，通过模块化的JavaScript代码，加上函数式编程，并且无需考虑浏览器兼容性问题，直接使用最新的ES6标准，可以完全满足工程上的需求。

### npm/yarn

1. 首先npm/yarn是一个包管理工具，可以使开发者更方便地分享和重用代码、更方便地更新自己分享的代码。

   举例来说：

   如果我们在开发过程中使用react，那么是不是要引入react.js，你可能会下载这个react.js文件， 然后在代码中<script src="react.js"></script>是吧； 如果使用 npm  ，那么就方便了，直接在npm下使用命令：$ npm install react；就自动下载了；

2. 当我们引用了其他开发者的代码时，很容易检测出代码是否更新，可以很方便地下载更新代码。

**npm的功能**

1. 将特定功能的代码分享出去，以便他人重用
2. **当我们引用了其他开发者的代码时，很容易检测出代码是否更新，可以很方便地下载更新代码**。

**npm的管理方式**

在项目中npm会创建一个特殊的package.json的文件，package.json以元数据的形式定义了**项目开发所需的依赖包**。这样，便可以将这些小的解决单一问题的依赖包定义组织在一起，为这个项目提供大的可定制的依赖集。

**Yarn是由Facebook、Google、等联合推出了一个新的 JS 包管理工具 ，正如[官方文档](https://link.zhihu.com/?target=https%3A//code.facebook.com/posts/1840075619545360)中写的，Yarn 是为了弥补 npm 的一些缺陷而出现的。**

- `npm install`的时候**巨慢**。特别是新的项目拉下来要等半天，删除node_modules，重新install的时候依旧如此。
- 同一个项目，安装的时候**无法保持一致性**。

### Yarn的优点

- **速度快** 。速度快主要来自以下两个方面：

1. **并行安装**：无论 npm 还是 Yarn 在执行包的安装时，都会执行一系列任务。npm 是按照队列执行每个 package，也就是说必须要等到当前 package 安装完成之后，才能继续后面的安装。而 Yarn 是同步执行所有任务，提高了性能。
2. **离线模式**：如果之前已经安装过一个软件包，用Yarn再次安装时之间从缓存中获取，就不用像npm那样再从网络下载了。

### **webpack** [详情](https://segmentfault.com/a/1190000006178770)

WebPack可以看做是**模块打包机**：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（TypeScript，Scss等），并将其转换和打包为合适的格式供浏览器使用。

Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个（或多个）浏览器可识别的JavaScript文件。

---

## 5. SVG 概念

svg(scalable vector graphics)，可伸缩矢量图形，使用XML格式定义图形。 
svg图像在放大或改变尺寸的情况下其图形质量不会有所损失。

### 优势：

- 与JPEG和gif比较，尺寸更小，且可压缩性更强
- SVG图形是可交互的和动态的，可以在SVG文件中添加事件或嵌入动画元素。 
- 图像在任何分辨率下也是可以打印高质量打印
- svg可在图像质量不下降的情况下被放大

与 Flash 相比，SVG 最大的优势是与其他标准（比如 XSL 和 DOM）相兼容。而 Flash 则是未开源的私有技术。 

---

## 6. websocket/HTTP/HTTPS协议区别

### WebSocket协议  [详情](https://segmentfault.com/a/1190000014149542?utm_source=tag-newest)

WebSocket协议是基于TCP的一种新的网络协议，**不同于HTTP协议的短连接**，它是一个全双工通讯可以实现客户端和服务器端的长连接，**双向实时通信 **。WebSocket最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，广泛应用于社交聊天、直播、实况更新等。

**WebSocket和Http协议都属于应用层协议，两者都基于传输层的TCP协议。**
websocket协议本质上是一个基于tcp的协议，是先通过HTTP/HTTPS协议发起一条特殊的http请求进行握手后创建一个用于交换数据的TCP连接，或者说**借用**了HTTP的协议来完成一部分握手。在握手阶段是一样的此后服务端与客户端通过此TCP连接进行实时通信

### HTTP协议

概念：HTTP协议是一个客户端和服务器端请求和应答的标准（TCP），用于从服务器传输超文本到本地浏览器的传输协议，属于应用层的一个协议，由于其简捷、快速的方式成为互联网上应用最为广泛的一种网络协议。

**一次完整的HTTP事物的工作流程：**

1. 首先是域名解析
2. 发起TCP的三次握手
3. TCP链接成功后发起HTTP请求报文（报文格式：请求行get/post方法）、消息报头、请求正文）
4. 服务器响应HTTP请求
5. 拿到HTML后浏览器开始解析HTML代码
6. 浏览器对页面进行渲染呈献给用户

**注意点：**

1. TCP的三次握手；

   比如说，今天我想约一个朋友去吃饭，然后我要确定她有没有时间，所以我要给她发微信或者QQ 比如说“小李，在吗”，然后她收到消息回复我 “在的”，然后我这边收到她在的消息就可以给她说我今天想和她一起去吃饭这件事，再给她回复说“那今天一起去吃饭”。

2. get/post请求方法：[详情](http://www.techweb.com.cn/network/system/2016-10-11/2407736.shtml)

   get方式是把数据放到URL中，跟着网址一块来传递

   post 提交数据给指定的服务器处理，常用于提交表单。

### HTTPS协议

HTTP协议以明文方式发送内容，不提供任何方式的数据加密，因此使用HTTP协议传输隐私信息非常不安全，为了数据传输的安全，HTTPS在HTTP的基础上加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。

>SSL(Secure Sockets Layer 安全套接层),及其继任者传输层安全（Transport Layer Security，TLS）是为[网络通信](https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1/9636548)提供安全及[数据完整性](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%AE%8C%E6%95%B4%E6%80%A7/110071)的一种安全协议。TLS与SSL在[传输层](https://baike.baidu.com/item/%E4%BC%A0%E8%BE%93%E5%B1%82/4329536)对网络连接进行加密。 

---

## 7. git 分支管理方式

我们现在的项目常用的是私有的Git 仓库来管理代码版本。采用的是GitHub flow的分支管理方式。

 GithubFlow 主要提供了**权限管理**，减少了主干分支污染的可能性，它依托于 GitHub 的 pull request 功能。当需要进行修改时，从 master 分支创建一个新的分支。所有相关的代码修改都在新分支中进行。开发人员可以自由地提交代码和 push 到远程仓库。当新分支中的代码全部完成之后，通过 GitHub 提交一个新的 pull request。

### Git使用规范

**[详情](https://blog.csdn.net/u010658879/article/details/50975084)**

![git流程](C:\Users\12090\Desktop\前端总结\git流程.PNG)

1. fork 将别人的仓库复制到自己的git上。 
2. clone 到本地仓库。 
3. 新建分支，修改提交A 
4. 修改提交B 
5. 远程master有更新C 
6. rebase操作 
7. push到自己的远程仓库 
8. 申请提交pull request 

---

## 8. deck.gl介绍

最近在学习Uber的一个**数据可视化框架** 叫deck.gl 。Uber去年宣布推出了内部使用的数据可视化框架 **deck.gl** 的开源版本。deck.gl 是一个 WebGL 驱动的框架，专门用于**大规模探索**和**可视化**数据集 。它具有提供不同类型可视化图层，GPU渲染的高性能，与React集成，结合地理信息数据的特点。  **deck.gl 是基于地理信息数据的，所以可视化很多都会分层两层，一层是地图数据底图，一层是可视化的数据。** 

deck.gl为用户专注于以下关键方面：

- **性能：**基于最新的WebGL技术，获得大数据集（数百万点或顶点）的高性能呈现，包括动态聚合和视觉探索等功能。
- **精度：**多亏我们定制的fp64数学库，在GPU上实现了高精度数值计算。据我们所知，当前基于WebGL的其他库并没有提供此功能，而该功能对地理数据集的完全交互至关重要。
- **可扩展性：**使用最新的编码标准，包括[ES2016](http://javascriptplayground.com/blog/2016/02/es2016-and-beyond/)，丰富的库生态系统，以及能够轻松地调试和分析WebGL应用程序的设置。



