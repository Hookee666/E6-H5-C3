# React 知识点整理

## React是什么？

**首先它是一个处理用户界面的视图层框架**，也就是react本身就是一个只负责显示部分的框架，真正严格说来说它都不能算作一个框架，这就决定了react本身是不太复杂的，不像Angular那样要处理很多事务，但这个框架有一些自己的独特设计，打破了之前开发方式的思维定势，这个框架的组织方式也**抛弃了传统的继承模式，而是使用了组件化的方式来开发**。

下来就是比较有特点的是它**采用JSX表达**式，这是在react里才有的一种表达方式，我们用它来处理数据和DOM之间的关系，而不用我们再去操作DOM，它把原本静态的模板字符串变成了JSX表达式，这使得在编程的时候灵活性会更大一些。

最后react还有一个突出的特点，就是**react采用的虚拟DOM的机制**，虚拟DOM是一种机制，简单的说就是它只有在必要的时候才去操作DOM，它通过减少低效的操作来提高整体性能。

- **视图层框架**
  react框架本身提供就是页面显示的功能，跟显示有关的主要是两个事，一个是能把数据变成DOM显示出来，而另外一件事就是处理在DOM上触发的事件，把DOM事件在转回给数据，在Angular或者Vue这中双向数据绑定的框架里，这两件事是放在一起做的，而在React上这是两个分开的部分，

  这个框架是一个声明式的框架，也是在它里面你只需要声明你想干什么就够了，涉及具体怎么做react框架会帮你完成，它不用像在命令式（Jquery）编程里那样，去指挥它怎么渲染，怎么调用之类的，而在react中只需要定义好数据和DOM之间的对应关系就可以了，当数据该改变的时候DOM会跟着自动变化。

  react数据处理方式，它采用数据驱动DOM，也就是数据变了DOM会跟着变，而DOM上的变化不像双向绑定那样直接反馈数据，而是要通过事件把DOM变化返回给数据。

- **组件化**

  在react中推荐使用组件的方式来组织项目结构，而不是采用传统的面向对象的方式，通过继承来实现代码的封装，这是因为组合相当于继承更灵活，通过组合的方式也不会受到继承里的约束。

  react组件提供了state和props两个主要的属性，state就是react里的数据，或者称它为状态，props是做父子组件通信用的，子组件可以通过props拿到父组件传来的数据和方法。

- **JSX表达式**

- **虚拟DOM**

  在React中会把定义好的**JSX标记**最终转化为为虚拟DOM存在内存里，这是因为内存的读取速度要比操作DOM快得多，如果用户做了对DOM可能产生影响操作的时候，虚拟DOM会把操作前后的数据进行对比，如果发现操作前后数据有变化，就会把所有的变动然后统一操作一次DOM，如果发现操作前后的数据没有差异的话就不会再去操作DOM。

  虚拟DOM的思路就是不到万不得已就不会去做低效的DOM操作，虚拟DOM有两大优势，一个是操作DOM前会对数据进行对比，只有数据变化的时候才去操作DOM，第二点它是会整合DOM操作，不像Jquery或者原声开发那样，数据如果发生变化可能有好几处的DOM需要操作，这样就会操作很多次，通过虚拟DOM的这种机制可以减少很多次DOM渲染，从而提高ｗｅｂ应用的性能。

## React优点

1. **简洁**

   这里说的简洁并不是语法有多简单，而是当业务流程复杂的时候就会发现单向数据流和组件化的组合方式会很大程度上降低问题的复杂度。

2. **灵活**

   在react里可以把一切理解为JS，这样操作起来就少了很多的树，另外组件提供了多种嵌套方式，数据驱动，生命周期等特点，也让开发变得更顺畅。

3. **高效**

   通过减少和优化对DOM的操作，能让react在浏览器会有更好的性能表现。

## React缺点

1. **思维转换**
   使用React编程的方式要跟着转过来，比如　JSX单项数据流等

2. **依赖生态**

   React本身只是一个视图层的框架，甚至不能称之为可框架，如果想让React发挥更大作用的话就需要依赖他的生态系统，比如果说处理单页路由，要用React-router，处理数据会用到 redux，所以需要了解更多的知识，然后这个系统也比较复杂。

3. **变动频繁**

   React更新比较频繁，并且不向前兼容，这就导致一升级可能就会出现各种问题。

---

## 组件间的数据传递方式

1. **父组件向子组件传值**，通过props就可以

2. **子组件向父组件传值**，通过回调，

   在父组件里向子组件传递了一个函数(changeColor),这个函数在父组件里绑定的是setState事件函数(bgColorChange)在子组件里点击事件里就可以通过this.props.changeColor(color)传参给父组件,从而就可以在子组件里传递参数而该百年父组件的状态。

3. **兄弟组件间的传递**：兄弟1通过给父组件传值然后再通过父组件改变兄弟2的状态。

4. **状态提升**

   **为了在兄弟组件间进行通讯，然后把子组件应该有的属性放到了父组件里，这种就是React里的状态提升**

---

## React生命周期

概念：生命周期就是一个组件从生到死的过程。然后生命周期是普遍存在，比如我们一个系统，一个页面，一个组件甚至一个变量都有生命周期，

在react里面，react为生命周期提供一些关键的结点，其实就是后续触发的事件，来让组件能方便的处理各种场景。

### **React生命周期分为三个阶段**

最后组件销毁时，执行`componentWillUnmount()`来处理一些收尾的逻辑。

- **Mouting  挂载阶段**： 组件第一次在DOM树渲染的过程。
- **Updating  更新阶段**：当组件的props或者state改变时就会触发组件的更新过程。
- **Unmounting  卸载阶段**：将组件从DOM树移出，防止内存溢出。

#### 挂载阶段
![加载阶段](https://github.com/wukee/JS-ES6-HTML5-CSS3-React/blob/master/image/加载阶段.PNG)
```
首先在组件加载的时候先是执行构造函数constructor() ，然后执行componentWillMount()组件将要执行（在这里可以加载异步的方法），然后再执行render() 渲染组件，最后再执行componentDidMount() 组件加载完成，这时已经生成了真实的DOM节点。
```

#### 更新过程
![更新阶段](https://github.com/wukee/JS-ES6-HTML5-CSS3-React/blob/master/image/更新阶段1.PNG)
![更新阶段](https://github.com/wukee/JS-ES6-HTML5-CSS3-React/blob/master/image/更新阶段2.PNG)

```
在更新过程中，如果是state的更新，它会先执行shouldComponentUpdate()这个方法来判断是否更新子组件，如果是，则往下进行，执行 componentWillUpdate() 组件将要更新  然后再 执行render() 渲染更新后的组件 再执行componentDidUpdate() 组件更新完成。这是整个更新过程就完成了。但如果是 props引起的数据改变 这里面会多个componentWillReceiveProps()来执行父组件传来的props。
```

#### 卸载过程
![卸载阶段](https://github.com/wukee/JS-ES6-HTML5-CSS3-React/blob/master/image/卸载阶段.PNG)

```
最后组件销毁时，执行componentWillUnmount()来处理一些收尾的逻辑。在这里做的通常是一些取消操作，比如说做了定时器，当组件消失的时候要把定时器关掉，减少内存占用。
```

## React技术栈（全家桶）

1. React主体
2. WebPack: grunt、gulp 自动化构建工具
3. Flex：布局
4. React-Route：路由
5. Redux：做view层编写
6. Mocha：测试
7. Istanbul：覆盖率

## JSX

1. 增强型的JS，
2. babel：为新JS语法做的编译器，支持ES6；注意了解下 bower

## state

1. 状态是活的

   constructor里面只能这样写satae ——`this.state={}`

   方法里面这样写——`this.setState({JSON})`

2. 事件大小写不能乱写

   `onChange` ，`onClick`，……

3. 绑定事件

   `onChange={this.fn.bind(this)}`

4. 用constructor的时候，必须要用`super()`，（super调用父类构造函数）

## React 组件节点获取，表单，数据交互等；

组件内的节点（元素）获取用 ref

`ref='类似id'`，  `this.refs['名字']` =>原生

但推荐使用 state（状态）

表单原件问题：

1. 用`value`，改成`defaulValue`
2. 用`checked`，改成`defaultChecked`